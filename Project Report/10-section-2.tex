يمكن تصور تعميم الخوارزميات السابقة لسرب من الروبوتات بشكل مبسط بالشكل الآتي: نقوم بحساب المسار الأمثل لكل روبوت على حدى باعتبار كل بقية الروبوتات على أنها عوائق، وإعادة توليد هذه المسار بشكل مستمر باستخدام التغذية الراجعة من الكاميرا، ولكن وبسبب طبيعة هذه عمل هذه الخوارزميات لا يمكن تطبيق هذا المفهوم البسيط على أرض الواقع. فكما نجد في \cite{d7} عند استخدام خوارزمية A* لتوليد مسار لسرب من الروبوتات، تطلب التطبيق عدة عمليات معالجة لاحقة وتنظيم لحركة الروبوتات لمنع التصادم، كما تمت الحاجة لتصميم وحل مسألة برمجة خطية لتقليل طول المسار وزمن الوصول.
بالحالة العامة وفي معظم مسائل تخطيط المسار لسرب روبوتات، الهدف هو إيصال كل روبوت من نقطة البداية إلى نقطة الهدف بدون حدوث أي تصادم. كما وجدنا في الدراسة السابقة، فإن الكثير من الدراسات السابقة تعتمد تحسينات على خوارزميات تخطيط المسار التقليدية. في \cite{d7} تم تقدم تقديم خوارزمية جديدة تسمي البحث المعتمد على التصادم\textenglish{ Conflict Based Search (CBS)} وهي طريقة مثلى تتكون من مرحلتين ،مرحلة عالية المستوى ومرحلة منخفصة المستوى. في المرحلة المرتفعة المستوى، يتم البحث في ما يسمى شجرة التصادم\textenglish{ Conflict Tree(CT)} وهي شجرة تُبنى بناء على التصادك بين الروبوتات والعوائق، كل عقدة في الشجرة تمثل مجموعة قيود على حركة الروبوتات. في المرحلة المنخفضة المستوى، تتم عملية بحيث سريع بما يحقق القيود المطروحة في الطبقة العالية المستوى. في معظم الحالات تحقق هذه الخوارزمية مسحاً لعدد أقل من العقد بالمقارنة مع A* وتحافظ في نفس الوقت على الأمثلية.


\subsection{تعريف مسألة CBS}

نعرف كل قيد على أنه ثلاثية بالشكل $ (a_i,\ v,\ t) $ حيث أن الروبوت $ a_i $ ممنوع من المرور بالعقدة v في الزمن t، خلال إيجاد الحل سيتم ربط كل روبوت بعدد من القيود ولاحقا يجب إيحاد مسار لكل روبوت بحيث يحقق كل قيوده
تعرف التصادم على أنه رباعية بالشكل $ (a_i,a_jو v,t) $ مما يدل على أن الروبوتات $ a_i $ و  $ a_j $ تشغل نفس العقدة v في الزمن $ t $. يكون الحل المكون من k  مسار (عدد الروبوتات هو k) صحيحاً عندما تكون كل المسارات خالية من أي تصادمات.
المرحلة عالية المستوى:

حيث يتم بناء شجرة CT وهي شجرة ثنائية كل عقدة منها تتكون من:

\begin{itemize}
	
	\item مجموعة قيود (N.constraints): كل قيد ينتمي لروبوت، عقدة الجذر لا تحتوي على أية قيود وكل عقدة ابن ترث قيود العقدة الأم وتضيف قيداً جديداً.
	
	\item حل (N.solution): مجموعة مسارات بعدد k، بحيث أن مسار كل روبوت يحقق القيود المفروضة عليه. يتم إيجاد هذه المسارات من خلال بحث في المرحلة منخضة المستوى.
	
	\item تكلفة كلية (N.cost): تكلفة مسارات كل الروبوتات. تسمى هذه التكلفة f-value   للعقدة N.
	
\end{itemize}

\textbf{إيجاد المسار وفق شجرةCT :}

تتم عملية البحث عن مسار كل روبوت في المرحلة منخضة المستوى وذلك بمعرفة جميع القيود، عند إيجاد المسارات (المسار الخاص بكل روبوت وفق قيوده) يتم اختبارصحتها. يتم الاختبار من خلال المرور على كل المواقع في كل الأزمنة والتحقق من عدم وجود أي روبوتين في نفس المكان والزمن.في حال تم العثور على تصادم، تتوقف العملية وننتقل إلى مرحلة حل التصادم.
حل التصادم:
عند حدوث تصادم من الشكل $ (a_i,a_j, v,t) $، نجد بديهياً أنه يجب لإضافة إما $ (a_i,\ v,\ t) $ أو $ (a_j,\ v,\ t) $ إلى قائمة القيود N.constraints. لضمان أمثلية الحل، يتم اختبار الحالتين وتنقسم العقدة N  إلى عقدتين ترثان قيود العقدة الأم وتضيفان قيد الربوبت الأول والروبوت الثاني على الترتيب. يوضح الجدول 1 خوارزيمة طريقة CBS للمرحلة عالية المستوى.

\begin{english}
	\begin{algorithm}[H]
		\DontPrintSemicolon
		
		\KwIn{MAPF instance}
		\KwOut{Your output}
		
		$Root.constraints \leftarrow \Phi$\;
		 $Root.solution \leftarrow$ find individual paths by low level procedure\;
		 $Root.cost = SIC(Root.solution)$\;
		 insert $RoottoOpen$\;
		
		\While{$Open \neq \Phi$}
		{
			 $P \leftarrow $ best node from Open;\;
			 Validate paths from open until a conflict occures\;
			\If{P has no conflict}
			{
				 Return P.solution
			}
			 $C \leftarrow first conflict (a_i, a_j, v,t) in P$\;
			
			\ForEach{$ agent a_i in C $}
			{
				 $A \leftarrow new node$ \;
				 $A.constrains \leftarrow P.constraints + (a_i, v, t)$\;
				 $A.solution \leftarrow P.solution$\;
				 Update $A.solution $ invoking low level $a_i$\;
				 $A.cost \leftarrow SIC(A.solution)$\;
				\If{$A.cost < \inf$}
				{
					
					 Insert A to Open\;
				}
			}
		}
		\caption{High Level CBS}
	\end{algorithm}

\end{english}

